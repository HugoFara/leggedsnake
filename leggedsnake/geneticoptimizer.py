#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
The geneticoptimizer module provides optimizers and wrappers for GA.

As for now I didn't tried a convincing Genetic Algorithm library. This is why
you can either use PyGAD or the built-in version. The switch between versions
is made automatically on whether or not you have PyGAD installed.

Created on Thu Jun 10 21:20:47 2021.

@author: HugoFara
"""
import warnings
import numpy as np
from numpy.random import rand, normal, randint
from pylinkage.geometry import dist
# Optimization by genetic algorithm
try:
    from pygad import GA
except ModuleNotFoundError:
    GA = None
# Progress bar
try:
    from tqdm import tqdm
except ModuleNotFoundError:
    tqdm = None


def tqdm_verbosity(iterable, verbose=True, *args, **kwargs):
    """Wrapper for tqdm, that let you specify if you want verbosity."""
    if verbose and tqdm:
        for i in tqdm(iterable, *args, **kwargs):
            yield i
    else:
        for i in iterable:
            yield i


def load_population(file_path):
    """Return a population from a given file."""
    f = open(file_path, 'r')
    pop = []
    for line in f.readlines():
        if line[0] == '{' and line[-2] == '}':
            pop.append([{}, 0, []])
            for i in line[1:-2].split(", "):
                j = i.replace("'", '').split(": ")
                pop[-1][0][j[0]] = float(j[1])
                ############################
                # Warning: does not consider user's choice
                """if j[0] != prob:
                    prob = .07"""
        elif line[0] == '[' and line[-2] == ']':
            for i in line[2:-3].split('), ('):
                j = i.split(', ')
                pop[-1][2].append((float(j[0]), float(j[1])))
    return pop


def birth(par1, par2, prob):
    """
    Return a new individual with par1 and par2 as parents (two sequences).

    Child are generated by a uniform crossover followed by a random "resetting"
    mutation of each gene. The resetting is a normal law.

    Initial positions come from one of the two parents randomly.

    Parameters
    ----------
    par1 : list[float, tuple[float], tuple[tuple[float]]]
        Dna of first parent.
    par2 : list[float, tuple[float], tuple[tuple[float]]]
        Dna of second parent.
    prob : list[float]
        Probability for each gene to mutate, width of a normal law.

    Returns
    -------
    child : list[float, tuple[float], tuple[tuple[float]]]
        Dna of the child.

    """
    child = [0, [], []]
    for gene1, gene2 in zip(par1[1], par2[1]):
        child[1].append(normal((gene1 if rand() < .5 else gene2), prob))
    for pos1, pos2 in zip(par1[2], par2[2]):
        child[2].append(pos1 if rand() < .5 else pos2)
    return child


def evaluate_population(pop, fitness, fitness_args, verbose=True):
    """Evaluate the whole population, attribute scores."""
    for dna in pop:
        if fitness_args is not None:
            fit = fitness(dna, *fitness_args)
        else:
            fit = fitness(dna)
        # Score
        dna[0] = fit[0]
        if len(fit[1]):
            # Don't change initial positions for unbuildable individual.
            dna[2] = fit[1]
    if verbose:
        diversity = np.linalg.norm(
            np.var([dna[1] for dna in pop], axis=0)
        )
        print("Scores:", [dna[1] for dna in pop])
        print("Genetic diversity: ", diversity)


def select_parents(pop, verbose=True):
    """Selection 1/4 of the population as parents."""
    median = np.median([dna[0] for dna in pop])
    # Index of best individual
    best_index, best_dna = max(enumerate(pop), key=lambda x: x[1][0])
    # Parents selection, 1/4 of population
    parents = []
    indexes = []
    for j, individual in enumerate(pop):
        # Parents whose score is above median.
        # Individuals with best fitness are more likely to be selected
        if (
                .5 * (individual[0] - best_dna[0]) / (best_dna[0] - median)
        ) + 1 > max(rand(), .5):
            parents.append(individual)
            indexes.append(j)
    # Add best individual if needed
    if best_index not in indexes:
        parents.insert(0, best_dna)
        indexes.append(best_index)
    # Add a random parent if odd number
    if len(parents) % 2:
        for j, individual in enumerate(pop):
            if j not in indexes:
                parents.append(individual)
                indexes.append(j)
                break
    if verbose:
        print(f"Median score: {median}, {len(parents)} parents\n----")
    return parents


def make_children(parents, prob, max_genetic_dist=float('inf')):
    children = []
    j = 0
    while len(parents) > 1 and j < 100:
        par1 = parents.pop(randint(len(parents) - 1))
        if len(parents) > 1:
            par2 = parents.pop(randint(len(parents) - 1))
        else:
            par2 = parents.pop()
        if dist(par1[1], par2[1]) < max_genetic_dist:
            children.append(birth(par1, par2, prob))
        elif parents:
            parents.append(par1)
            parents.append(par2)
        j += 1
    return children


def evolutionary_optimization_builtin(
        dna,
        prob,
        fitness,
        iters,
        max_pop=11,
        init_pop=None,
        max_genetic_dist=.7,
        startnstop=False,
        fitness_args=None,
        verbose=1,
):
    """
    Optimization by genetic algorithm (GA).

    Parameters
    ----------
    dna : list[float, tuple[float], tuple[tuple[float]]]
        DNA of individuals.
    prob : list[float]
        List of probabilities of the good transmission of one
        characteristics.
    fitness : callable
        Evaluation function.
        Return float.
        The
    iters : int
        Number of iterations.
    max_pop : int, optional
        Maximum number of individuals. The default is 11.
    init_pop : sequence of object, optional
        Initial population, for wider INITIAL genetic diversity.
        The default is None.
    max_genetic_dist : float, optional
        Maximum genetic distance, before individuals
        cannot reproduce (separated species). The default is .7.
    startnstop : bool, optional
        Ability to close program without loosing population.
        If True, we verify at initialization the existence of a data file.
        Population is save every int(250 / max_pop) iterations.
        The default is False.
    fitness_args : sequence, optional
        Positional arguments to send to the fitness function.
        The default is None (no argument sent).
    verbose : int, optional
        Level of verbosity.
        0 : no verbose, do not print anything.
        1 : show a progress bar.
        2 : complete report for each turn.
        The default is 1.

    Returns
    -------
    list[float, tuple[float], tuple[tuple[float]]]
        List of 3-tuples: best dimensions, best score and initial positions.
        The list is sorted by score order.
    """
    file_path = 'Population data.txt'
    if startnstop:
        pop = load_population(file_path)
    else:
        # At least two parents to begin with
        pop = [[dna[0], list(dna[1]), list(dna[2])] for _ in range(2)]

    # "Garden of Eden" phase, add enough children to get as much individuals as
    # required
    if not init_pop:
        init_pop = max_pop
    for i in range(len(pop), init_pop):
        pop.append(
            birth(
                pop[randint(len(pop) - 1)],
                pop[randint(len(pop) - 1)],
                prob
            )
        )
    postfix = ["best_score", dna[0], "best_dimensions", dna[1]]
    iterations = tqdm_verbosity(
        range(iters),
        verbose=verbose == 1,
        total=iters,
        desc='Evolutionary optimization',
        postfix=postfix
    )
    print("verbose", verbose)
    for i in iterations:
        if verbose:
            print(f"Turn: {i}, {len(pop)} individuals.")
        # Individuals evaluation
        evaluate_population(pop, fitness, fitness_args, verbose=verbose > 1)
        # Population selection
        # Minimal score before death
        death_score = np.quantile([j[0] for j in pop], 1 - max_pop / len(pop))
        if np.isnan(death_score):
            death_score = - float('inf')
        # We only keep max_pop individuals
        pop = list(filter(lambda x: x[0] >= death_score, pop))
        parents = select_parents(pop, verbose=verbose > 1)
        # We select the best fit individual to show off, we now he is a parent
        postfix[1] = max(parents, key=lambda x: x[0])[0]
        postfix[3] = max(parents, key=lambda x: x[0])[1]
        if startnstop and not i % int(250 / max_pop):
            file = open(file_path, 'w')
            for j in pop:
                file.write('%s\n%s\n%s\n----\n' % (j[0], j[1], j[2]))
            file.close()
            if verbose > 1:
                print('Data saved.')
        # Children generation
        children = make_children(parents, prob, max_genetic_dist)
        # Add to population
        pop.extend(children)

    out = []
    for dna in pop:
        fit = fitness(dna)
        if isinstance(fit, tuple):
            out.append((fit[0], fit[1], dna[2]))
        else:
            out.append((fit, dna[1], dna[2]))
    out.sort(key=lambda x: x[0], reverse=True)
    return out


def evolutionary_optimization(
        dna,
        fitness,
        iters,
        prob=.1,
        max_pop=11,
        init_pop=None,
        max_genetic_dist=.7,
        startnstop=False,
        fitness_args=None,
        verbose=1,
):
    """
    Run the Genetic Optimizer.

    Genetic Optimization is a procedural algorithm based on Darwinian evolution
    models.

    This function can use either PySwarms.GA if found, and automatically
    falls backs to the legacy algorithm if not.

    Parameters
    ----------
    dna : list[float, tuple[float], tuple[tuple[float]]]
        DNA of a linkage in format (score, dimensions, initial coordinates).
    prob : float
        Mutation probability (PyGAD only).
    fitness : callable
        Evaluation function for an MAXIMISATION problem.
        Must return a float.
    iters : int
        Number of iterations.
    max_pop : int, optional
        Maximum number of individuals. The default is 11.
    init_pop : Union[list[object], int], optional
        Initial population, for wider INITIAL genetic diversity. Can also we a
        number of individuals.
        The default is None.
    max_genetic_dist : float, optional
        Maximum standard deviation between the dimensions of two individuals.
        Above this limit they are considered different species and can't
        reproduce. The default is .7.
    startnstop : bool, optional
        Ability to close program without loosing population.
        If True, we verify at initialization the existence of a data file.
        Population is save every int(250 / max_pop) iterations.
        The default is False.
    fitness_args : sequence, optional
        Positional arguments to send to the fitness function.
        The default is None (no argument sent).
    verbose : int, optional
        Level of verbosity.
        0 : no verbose, do not print anything.
        1 : show a progress bar.
        2 : complete report for each turn.
        The default is 1.

    Returns
    -------
    list[dna]
        An iterable of the best fit individuals, in format
        (score, dimensions, initial coordinates).

    """
    def fitness_func(dims, index):
        """Wrapper for PyGAD which uses a different order."""
        fit = fitness([0, dims, dna[2]], *fitness_args)
        return fit[0]
    # If pyswarms.GA is installed
    if GA:
        def pygad_verbose(genetic_algorithm):
            if verbose:
                print("Best solution", genetic_algorithm.best_solution())
        natural_history = GA(
            num_generations=iters,
            num_parents_mating=int(np.ceil(max_pop / 10)),
            fitness_func=fitness_func,
            # initial_population=init_pop,
            sol_per_pop=max_pop,
            num_genes=len(dna[1]),
            init_range_low=0, init_range_high=5,
            crossover_type='uniform', crossover_probability=.5,
            mutation_type="random", mutation_probability=prob,
            on_generation=pygad_verbose
        )
        natural_history.run()
        natural_history.plot_result()
        return natural_history

    if not isinstance(init_pop, int):
        init_pop = len(init_pop)
    # Legacy fallback
    return evolutionary_optimization_builtin(
        dna, prob, fitness,
        iters=iters,
        max_pop=max_pop,
        init_pop=init_pop,
        max_genetic_dist=max_genetic_dist,
        startnstop=startnstop,
        fitness_args=fitness_args,
        verbose=verbose
    )


def evolutionnary_optimization(
        dna,
        fitness,
        ite,
        prob=.1,
        max_pop=11,
        init_pop=None,
        max_genetic_dist=.7,
        startnstop=False,
        fitness_args=None,
):
    """
    For backward compatibility ONLY.

    Please use the evolutionary_optimization function instead.
    """
    warnings.warn(
        "This function has been renamed to evolutionary_optimization and will "
        "get deleted in the next minor release.",
        DeprecationWarning
    )
    return evolutionary_optimization(
        dna=dna,
        fitness=fitness,
        iters=ite,
        prob=prob,
        max_pop=max_pop,
        init_pop=init_pop,
        max_genetic_dist=max_genetic_dist,
        startnstop=startnstop,
        fitness_args=fitness_args,
    )
